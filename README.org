Application management library and tools

* Usage
This packages manages various standard tasks needed by applications like:

- Program arguments
    - Parsing arguments
    - Standard arguments pre-defined:
#+begin_src
        -l, --log             Log file (stdout,stderr,file)
            --logsplit        Split log file per MPI rank
        -v, --verbose         Verbose level (ERROR,WARNING,INFO,DEBUG,EXTRA or 0-4)
            --verbosetime     Display time in logs (NONE,DATETIME,TIME,SECOND,MSECOND)
            --verbosecolor    Use color for log messages
        -h, --help            Help info
#+end_src

    - Logging
        - Standard and uniform way of displaying messages at various levels
        - Manages dependent libraries if they also use this mecanism (App_Log)
        - Optional time information, time step number and color by message type
        - When using MPI, messages are prepended by the PE number
        - Shows count of error and warnings at end/close of log
    - Process signal trapping
        - Signal trapping for stopping model on SIGUSR2/SIGTERM
    - Some parallel process management

** Environment variables
- APP_PARAMS       : List of parameters for the application (instead of giving on command line) 
- APP_VERBOSE      : Define verbose level (ERROR,WARNING,INFO,DEBUG,EXTRA,QUIET or 0-5) default:INFO
- APP_VERBOSECOLOR : Use color in log messages
- APP_VERBOSETIME  : Display time for each message (NONE,DATETIME,TIME,SECOND,MSECOND, or 0-4) default:NONE
- APP_LOGSPLIT     : Split log stream/file per MPI PE
- APP_LOGSTREAM    : Define log stream/file (stdout,stderr,filename) default:stderr
  
- CMCLNG           : Language to use (francais,english)
- OMP_NUM_THREADS  : Number of openMP threads (for internal purposes)

** Example output log
#+begin_src
-------------------------------------------------------------------------------------
Application    : Interpolate 0.1.0 (2022-11-08T12:31:34Z)
Lib RMN        : 20.0.0-alpha3-2-g1f0543f-dirty

Start time     : (UTC) Thu Nov 10 22:25:50 2022
-------------------------------------------------------------------------------------

(ERROR) W grid support not enabled, needs to be built with GDAL
(INFO) Processing TT 2049
(DEBUG) GeoRef_SetGet: RefFrom : 0x122c200 RefTo: 0x1215760
(ERROR) Def_GridInterp: Invalid destination
(ERROR) Interpolate: EZSCINT interpolation problem
-------------------------------------------------------------------------------------
Finish time    : (UTC) Thu Nov 10 22:25:50 2022
Execution time : 0.0539 seconds (0.03 ms logging)
Status         : Error 1 (3 Errors)
-------------------------------------------------------------------------------------
#+end_src

** Example code
#+begin_src C
int main(int argc,char **argv) {

   TIris    Iris;
   MPI_Comm comm;

   int   ok=0,code=0,timestep=0,s;
   char *gridfile=NULL;

   TApp_Arg appargs[]=
      { { APP_CHAR,  &gridfile, 1,             "g", "grid", "Input data fields" },
        { APP_NIL } };

   MPI_Init(&argc,&argv);

   App_Init(APP_MASTER,MODEL_NAME,VERSION,PROJECT_DESCRIPTION_STRING,BUILD_TIMESTAMP);
   if (!App_ParseArgs(appargs,argc,argv,APP_NOARGSFAIL|APP_ARGSLOG)) {
      code=EXIT_FAILURE;      
   }

   if (!gridfile) {
      App_Log(APP_ERROR,"No input standard file specified\n");
      exit(EXIT_FAILURE);
   }

   if (!code) {
      App_Start();
 
      comm=Iris_Init(&Iris,0,NULL);
      
      Model_Init(&Iris,gridfile);
      for(App->Step=1;App->Step<20;App->Step++) {

         if (App_IsDone()) {
            // Trapped premption signal
            break; 
         }
         Model_Run(&Iris, ++timestep, comm);
      }

      if (App_IsDone() && Iris.Rank==0) {
         App_Log(APP_WARNING,"MDL%d: Would be writing a restart here\n",Iris.ModelNo);
      }

      Iris_Model_Finalize(&Iris);
      code=App_End(ok?-1:EXIT_FAILURE);
   }
   if (Iris.Rank==0)
     cs_fstfrm(OutFID);

   App_Free();

   MPI_Finalize();
}
#+end_src


* Build dependencies

- CMake 3.21+

Note: =cmake_rpn= is included as a submodule.  Please clone with the
=--recursive= flag or run =git submodule update --init --recursive= in the
git repo after having cloned.

* At CMC

Source the right file depending on the architecture you need from the env directory.
This will load the specified compiler and define the ECCI_DATA_DIR variable for the test datasets

- Example for PPP3 and skylake specific architecture:

#+begin_src
. $ECCI_ENV/latest/ubuntu-18.04-skylake-64/intel-19.0.3.199.sh
#+end_src

- Example for XC50 on intel-19.0.5

#+begin_src
. $ECCI_ENV/latest/sles-15-skylake-64/intel-19.0.5.281.sh
#+end_src

- Example for CMC network and gnu 7.5:

#+begin_src
. $ECCI_ENV/latest/ubuntu-18.04-amd-64/gnu-7.5.0.sh
#+end_src

* Build and install

#+begin_src
mkdir build
cd build
cmake .. -DCMAKE_INSTALL_PREFIX=[your install path]-Drmn_ROOT=[rmnlib location]
make -j 4
make test
make install
#+end_src
