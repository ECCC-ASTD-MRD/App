Application management library and tools

* Usage
This packages manages various standard tasks needed by applications like:

- Program arguments
    - Parsing arguments
    - Standard arguments pre-defined:
#+begin_src
        -l, --log             Log file (stdout,stderr,file)
            --logsplit        Split log file per MPI rank
        -v, --verbose         Verbose level (ERROR,WARNING,INFO,DEBUG,EXTRA or 0-4)
            --verbosetime     Display time in logs (NONE,DATETIME,TIME,SECOND,MSECOND)
            --verbosecolor    Use color for log messages
        -h, --help            Help info
#+end_src

    - Logging
        Standard and uniform way of displying messages at various levels, with optional time information, time step number and color by message type. When using MPI, messages are prepended by the PE number. 
    - Process signal trapping
        You can define signal trapping functions but capability for stopping model on SIGUSR2 is already defined
    - Some parallel process management

** Environment variables
- APP_PARAMS       : List of parameters for the appliaction (instead of givins on command line) 
- APP_VERBOSE      : Define verbose level (ERROR,WARNING,INFO,DEBUG,EXTRA or 0-4) default:INFO
- APP_VERBOSECOLOR : Use color in log messages
- APP_VERBOSETIME  : Display time for each message (NONE,DATETIME,TIME,SECOND,MSECOND, or 0-4) default:NONE
- APP_LOGSPLIT     : Split log stream/file per MPI PE
- APP_LOGSTREAM    : Define log stream/file (stdout,stderr,filename) default:stdout
  
- CMCLNG           : Language tu use (francais,english)
- OMP_NUM_THREADS  : Number of openMP threads

** Example code
#+begin_src C
int main(int argc,char **argv) {

   TIris    Iris;
   MPI_Comm comm;

   int   ok=0,code=0,timestep=0,s;
   char *gridfile=NULL;

   TApp_Arg appargs[]=
      { { APP_CHAR,  &gridfile, 1,             "g", "grid", "Input data fields" },
        { APP_NIL } };

   MPI_Init(&argc,&argv);

   App_Init(APP_MASTER,MODEL_NAME,VERSION,PROJECT_DESCRIPTION_STRING,BUILD_TIMESTAMP);
   if (!App_ParseArgs(appargs,argc,argv,APP_NOARGSFAIL|APP_ARGSLOG)) {
      code=EXIT_FAILURE;      
   }

   if (!gridfile) {
      App_Log(APP_ERROR,"No input standard file specified\n");
      exit(EXIT_FAILURE);
   }

   if (!code) {
      App_Start();
 
      comm=Iris_Init(&Iris,0,NULL);
      
      Model_Init(&Iris,gridfile);
      for(App->Step=1;App->Step<20;App->Step++) {

         if (App_IsDone()) {
            // Trapped premption signal
            break; 
         }
         Model_Run(&Iris, ++timestep, comm);
      }

      if (App_IsDone() && Iris.Rank==0) {
         App_Log(APP_WARNING,"MDL%d: Would be writing a restart here\n",Iris.ModelNo);
      }

      Iris_Model_Finalize(&Iris);
      code=App_End(ok?-1:EXIT_FAILURE);
   }
   if (Iris.Rank==0)
     cs_fstfrm(OutFID);

   App_Free();

   MPI_Finalize();
}
#+end_src


* Build dependencies

- CMake 3.21+

Note: =cmake_rpn= is included as a submodule.  Please clone with the
=--recursive= flag or run =git submodule update --init --recursive= in the
git repo after having cloned.

* At CMC

Source the right file depending on the architecture you need from the env directory.
This will load the specified compiler and define the ECCI_DATA_DIR variable for the test datasets

- Example for PPP3 and skylake specific architecture:

#+begin_src
. $ECCI_ENV/latest/ubuntu-18.04-skylake-64/intel-19.0.3.199.sh
#+end_src

- Example for XC50 on intel-19.0.5

#+begin_src
. $ECCI_ENV/latest/sles-15-skylake-64/intel-19.0.5.281.sh
#+end_src

- Example for CMC network and gnu 7.5:

#+begin_src
. $ECCI_ENV/latest/ubuntu-18.04-amd-64/gnu-7.5.0.sh
#+end_src

* Build and install

#+begin_src
mkdir build
cd build
cmake .. -DCMAKE_INSTALL_PREFIX=[your install path]-Drmn_ROOT=[rmnlib location]
make -j 4
make test
make install
#+end_src
